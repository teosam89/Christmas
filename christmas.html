<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Christmas</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: #fff;
            z-index: 10;
        }
        h1 {
            font-size: 3rem;
            margin: 0;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 30px #00aaff; /* 改为极光色调的光晕 */
            animation: glow 3s ease-in-out infinite alternate;
        }
        p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-top: 10px;
            text-shadow: 0 0 5px #000;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 30px #00aaff; }
            to { text-shadow: 0 0 20px #00aaff, 0 0 30px #00aaff, 0 0 40px #ffffff; }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>
    </div>
    
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. 场景初始化 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        // 雾气稍微带点极光的蓝绿色
        scene.fog = new THREE.FogExp2(0x020a08, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 60;

        // --- 2. 灯光系统 ---
        const ambientLight = new THREE.AmbientLight(0x445566, 0.3); // 环境光偏冷色调
        scene.add(ambientLight);

        // 主光源 (月光)
        const dirLight = new THREE.DirectionalLight(0xaaccff, 0.8);
        dirLight.position.set(10, 30, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // 暖色聚光灯聚焦圣诞树
        const spotLight = new THREE.SpotLight(0xffaa55, 1.5);
        spotLight.position.set(-10, 20, 5);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        // --- 3. 对象创建函数 ---

        // 3.1 圣诞树 (保持不变)
        function createChristmasTree() {
            const treeGroup = new THREE.Group();
            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x0a5a0a, roughness: 0.7, flatShading: true });
            const levels = 5;
            for (let i = 0; i < levels; i++) {
                const size = 1 - (i * 0.15);
                const yPos = 1 + (i * 1.5);
                const geometry = new THREE.ConeGeometry(3.5 * size, 3, 8);
                const cone = new THREE.Mesh(geometry, leafMaterial);
                cone.position.y = yPos;
                cone.castShadow = true; cone.receiveShadow = true;
                treeGroup.add(cone);
                addOrnaments(treeGroup, 3.5 * size, yPos - 1.5, i);
            }
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1, 2.5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x3a1e02 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            const starGeometry = new THREE.IcosahedronGeometry(0.8, 0);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.y = levels * 1.5 + 1;
            treeGroup.add(star);
            const starLight = new THREE.PointLight(0xffcc00, 3, 15);
            starLight.position.y = levels * 1.5 + 1;
            treeGroup.add(starLight);

            return treeGroup;
        }

        function addOrnaments(group, radius, y, levelIndex) {
            const colors = [0xff0000, 0xffd700, 0x3366ff, 0xffffff];
            const count = 6 + levelIndex;
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2 + (levelIndex * 0.5);
                const x = Math.cos(angle) * (radius * 0.85);
                const z = Math.sin(angle) * (radius * 0.85);
                const geometry = new THREE.SphereGeometry(0.25, 16, 16);
                const material = new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)], metalness: 0.8, roughness: 0.2 });
                const ball = new THREE.Mesh(geometry, material);
                ball.position.set(x, y + 0.3, z);
                ball.castShadow = true;
                group.add(ball);
            }
        }

        // 3.2 雪人 (保持不变)
        function createSnowman() {
            const snowmanGroup = new THREE.Group();
            const snowMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            const coalMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1 });
            const carrotMaterial = new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.8 });

            const base = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), snowMaterial);
            base.position.y = 1.3; base.castShadow = true; base.receiveShadow = true;
            const middle = new THREE.Mesh(new THREE.SphereGeometry(1.1, 16, 16), snowMaterial);
            middle.position.y = 3.2; middle.castShadow = true; middle.receiveShadow = true;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), snowMaterial);
            head.position.y = 4.7; head.castShadow = true; head.receiveShadow = true;
            snowmanGroup.add(base, middle, head);

            const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const leftEye = new THREE.Mesh(eyeGeo, coalMaterial); leftEye.position.set(-0.3, 4.9, 0.65);
            const rightEye = new THREE.Mesh(eyeGeo, coalMaterial); rightEye.position.set(0.3, 4.9, 0.65);
            snowmanGroup.add(leftEye, rightEye);

            const noseGeo = new THREE.ConeGeometry(0.12, 0.5, 8);
            const nose = new THREE.Mesh(noseGeo, carrotMaterial);
            nose.geometry.rotateX(Math.PI / 2);
            nose.position.set(0, 4.7, 0.8);
            snowmanGroup.add(nose);
            return snowmanGroup;
        }

        // 3.3 麋鹿 (保持不变)
        function createReindeer() {
            const deerGroup = new THREE.Group();
            const furMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, flatShading: true });
            const antlerMaterial = new THREE.MeshStandardMaterial({ color: 0xd2b48c, flatShading: true });

            const body = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.2, 3), furMaterial);
            body.position.y = 1.8; body.castShadow = true;
            deerGroup.add(body);

            const legGeo = new THREE.BoxGeometry(0.4, 1.8, 0.4);
            const legPositions = [[-0.6, -1, 1.2], [0.6, -1, 1.2], [-0.6, -1, -1.2], [0.6, -1, -1.2]];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, furMaterial);
                leg.position.set(...pos); leg.castShadow = true;
                body.add(leg);
            });

            const head = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1.5), furMaterial);
            head.position.set(0, 1.2, 2); head.castShadow = true;
            body.add(head);
            
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0xff0000}));
            nose.position.set(0,0,0.8);
            head.add(nose);

            const antlerGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.5);
            const leftAntler = new THREE.Mesh(antlerGeo, antlerMaterial);
            leftAntler.position.set(-0.4, 0.8, -0.2); leftAntler.rotation.z = 0.5;
            head.add(leftAntler);
            const rightAntler = new THREE.Mesh(antlerGeo, antlerMaterial);
            rightAntler.position.set(0.4, 0.8, -0.2); rightAntler.rotation.z = -0.5;
            head.add(rightAntler);
            return deerGroup;
        }

        // 3.4 新增：极光 (Aurora)
        function createAurora() {
            // 创建一个巨大的平面，增加分段数以便进行波浪动画
            const geometry = new THREE.PlaneGeometry(200, 100, 64, 64);
            // 旋转平面使其直立
            geometry.rotateX(-Math.PI / 2); 
            
            // 使用 BasicMaterial，开启透明和加法混合，模拟发光效果
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff88, // 极光主色调：蓝绿色
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false // 防止遮挡其他透明物体（如雪花）
            });

            const auroraMesh = new THREE.Mesh(geometry, material);
            // 放置在场景后方高处
            auroraMesh.position.set(0, 30, -50);
            // 稍微倾斜，增加动感
            auroraMesh.rotation.x = Math.PI / 6; 

            // 保存初始顶点位置，用于动画计算
            auroraMesh.userData.initialPositions = geometry.attributes.position.array.slice();
            
            return auroraMesh;
        }

        // --- 4. 构建场景 ---
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeff, roughness: 0.6, metalness: 0.1 });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.2;
        ground.receiveShadow = true;
        scene.add(ground);

        const tree = createChristmasTree();
        scene.add(tree);

        const snowman = createSnowman();
        snowman.position.set(-6, -1.2, 4);
        snowman.rotation.y = Math.PI / 4;
        scene.add(snowman);

        const reindeer = createReindeer();
        reindeer.position.set(6, -1.2, 2);
        reindeer.rotation.y = -Math.PI / 3;
        scene.add(reindeer);

        // 添加极光
        const aurora = createAurora();
        scene.add(aurora);

        // 下雪效果
        const snowGeometry = new THREE.BufferGeometry();
        const snowCount = 2000;
        const posArray = new Float32Array(snowCount * 3);
        const velArray = new Float32Array(snowCount);
        for(let i = 0; i < snowCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 80;
            posArray[i+1] = Math.random() * 50;
            posArray[i+2] = (Math.random() - 0.5) * 80;
            velArray[i/3] = Math.random() * 0.06 + 0.03;
        }
        snowGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const snowMaterial = new THREE.PointsMaterial({ size: 0.2, color: 0xffffff, transparent: true, opacity: 0.8 });
        const snowParticles = new THREE.Points(snowGeometry, snowMaterial);
        scene.add(snowParticles);

        // --- 5. 动画循环 ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 树木自转
            tree.rotation.y += 0.002;

            // --- 极光动画 ---
            const positions = aurora.geometry.attributes.position.array;
            const initialPositions = aurora.userData.initialPositions;
            for (let i = 0; i < positions.length; i += 3) {
                const x = initialPositions[i];
                const z = initialPositions[i+2];
                // 使用正弦和余弦函数根据时间和位置创建波浪效果
                // 修改 Y 轴坐标 (在平面几何体旋转前是 Z 轴)
                positions[i + 1] = initialPositions[i + 1] + 
                                   Math.sin(x / 10 + time) * 5 + 
                                   Math.cos(z / 10 + time * 1.5) * 3;
            }
            // 标记位置属性需要更新
            aurora.geometry.attributes.position.needsUpdate = true;

            // 雪花下落
            const snowPositions = snowParticles.geometry.attributes.position.array;
            for(let i = 1; i < snowCount * 3; i+=3) {
                snowPositions[i] -= velArray[(i-1)/3];
                if (snowPositions[i] < -1) {
                    snowPositions[i] = 40;
                    snowPositions[i-1] = (Math.random() - 0.5) * 80;
                    snowPositions[i+1] = (Math.random() - 0.5) * 80;
                }
            }
            snowParticles.geometry.attributes.position.needsUpdate = true;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
